using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using Xunit;

namespace Euler
{
    /// <summary>
    /// Highly divisible triangular number
    /// 
    /// The sequence of triangle numbers is generated by adding the natural numbers.
    /// So the 7**th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
    /// The first ten terms would be:
    /// 
    /// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    /// 
    /// Let us list the factors of the first seven triangle numbers:
    /// 
    ///  1: 1
    ///  3: 1, 3
    ///  6: 1, 2, 3, 6
    /// 10: 1, 2, 5,10
    /// 15: 1, 3, 5,15
    /// 21: 1, 3, 7,21
    /// 28: 1, 2, 4, 7,14,28
    /// 
    /// We can see that 28 is the first triangle number to have over five divisors.
    /// 
    /// What is the value of the first triangle number to have over five hundred divisors?
    ///
    /// <seealso href="https://projecteuler.net/problem=12"/>
    /// </summary>
    public sealed class Problem012
    {            
        private const string Answer = @"76576500";
                
        [Fact]
        public void Test()
        {
            var actual = GetAnswer();
            Assert.Equal(Answer, actual);
        }        

		[Fact]
        public void WellKnownTest()
        {
            var actual = GetAnswer(5);
            Assert.Equal("28", actual);
        }

        public static string GetAnswer(int divCount = 500)
        {
            throw new NotImplementedException();
        }




        [Fact]
        public void GetPosPowerSequenceTest2()
        {
            var actual = string.Join(",",
                GetPosPowerSequence(2).Take(10));
            Assert.Equal("1,2,1,3,1,2,1,4,1,2", actual);
        }

        [Fact]
        public void GetPosPowerSequenceTest3()
        {
            var actual = string.Join(",",
                GetPosPowerSequence(3).Take(27));
            Assert.Equal("1,1,2,1,1,2,1,1,3,1,1,2,1,1,2,1,1,3,1,1,2,1,1,2,1,1,4", actual);
        }

        /// <summary>
        /// Returns sequence of NON-ZERO powers of prime.
        /// </summary>
        private static IEnumerable<int> GetPosPowerSequence(int prime)
        {
            for (var i = 1; ; i++)
            {
                foreach (var value in GetPosPowerSequence(prime, i))
                    yield return value;
            }
        }
        
        /// <summary>
        /// Tree iteration from left to right.
        /// </summary>
        private static IEnumerable<int> GetPosPowerSequence(int prime, int depth)
        {
            if (depth == 1)
            {
                for (var i = 1; i < prime; i++)
                    yield return 1;
                yield break;
            }

            var stack = new Stack<Tuple<int, bool>>();   // Tuple<Value, Print>, call recursive if not only print.

            for (var i = 1; i < prime; i++)
            {
                stack.Push(new Tuple<int, bool>(depth - 1, false));
                stack.Push(new Tuple<int, bool>(depth, true));
            }

            while (stack.Count > 0)
            {
                var top = stack.Pop();
                if (top.Item2)
                {
                    yield return top.Item1;
                }
                else if (top.Item1 == 1)
                {
                    for (var i = 1; i < prime; i++)
                        yield return 1;
                }
                else
                {
                    stack.Push(new Tuple<int, bool>(top.Item1 - 1, false));
                    for (var i = 1; i < prime; i++)
                    {
                        stack.Push(new Tuple<int, bool>(top.Item1, true));
                        stack.Push(new Tuple<int, bool>(top.Item1 - 1, false));
                    }
                }             
            }
        }

        

        #region OLD solution (very slow)

        public static string GetSlowAnswer(int divCount = 500)
        {
            var getDivCount = new Func<int, int>(number =>
            {              
                var counter = 2;
                for (var i = 2; i <= (number >> 1); i++)
                {
                    if ((number % i) == 0)
                        counter++;
                }
                return counter;
            });

            var n = 1;
            for (var i = 2; i < int.MaxValue; i++)
            {
                n = n + i;
                if (getDivCount(n) > divCount)
                {
                    return n.ToString(CultureInfo.InvariantCulture);
                }
            }

            throw new AnswerNotFoundException();
        }

        #endregion
    }
}
